<?php
/**
 * SMSRequest
 *
 * PHP version 5
 *
 * @category Class
 * @package  Swagger\Client
 * @author   http://github.com/swagger-api/swagger-codegen
 * @license  http://www.apache.org/licenses/LICENSE-2.0 Apache Licene v2
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * API iSendPro
 *
 * [1] Liste des fonctionnalités : - envoi de SMS à un ou plusieurs destinataires, - lookup HLR, - récupération des récapitulatifs de campagne, - gestion des répertoires, - ajout en liste noire. - comptage du nombre de caractères des SMS  [2] Pour utiliser cette API vous devez: - Créer un compte iSendPro sur https://isendpro.com/ - Créditer votre compte      - Remarque: obtention d'un crédit de test possible sous conditions - Noter votre clé de compte (keyid)   - Elle vous sera indispensable à l'utilisation de l'API   - Vous pouvez la trouver dans le rubrique mon \"compte\", sous-rubrique \"mon API\" - Configurer le contrôle IP   - Le contrôle IP est configurable dans le rubrique mon \"compte\", sous-rubrique \"mon API\"   - Il s'agit d'un système de liste blanche, vous devez entrer les IP utilisées pour appeler l'API   - Vous pouvez également désactiver totalement le contrôle IP
 *
 * OpenAPI spec version: 1.0.0
 * Contact: support@isendpro.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Swagger\Client\Model;

use \ArrayAccess;

/**
 * SMSRequest Class Doc Comment
 *
 * @category    Class */
/** 
 * @package     Swagger\Client
 * @author      http://github.com/swagger-api/swagger-codegen
 * @license     http://www.apache.org/licenses/LICENSE-2.0 Apache Licene v2
 * @link        https://github.com/swagger-api/swagger-codegen
 */
class SMSRequest implements ArrayAccess
{
    /**
      * The original name of the model.
      * @var string
      */
    protected static $swaggerModelName = 'SMSRequest';

    /**
      * Array of property to type mappings. Used for (de)serialization
      * @var string[]
      */
    protected static $swaggerTypes = array(
        'keyid' => 'string',
        'date_envoi' => 'string',
        'sms' => 'string[]',
        'num' => 'string[]',
        'emetteur' => 'string',
        'tracker' => 'string[]',
        'smslong' => 'string',
        'nostop' => 'string',
        'ucs2' => 'string'
    );

    public static function swaggerTypes()
    {
        return self::$swaggerTypes;
    }

    /**
     * Array of attributes where the key is the local name, and the value is the original name
     * @var string[]
     */
    protected static $attributeMap = array(
        'keyid' => 'keyid',
        'date_envoi' => 'date_envoi',
        'sms' => 'sms',
        'num' => 'num',
        'emetteur' => 'emetteur',
        'tracker' => 'tracker',
        'smslong' => 'smslong',
        'nostop' => 'nostop',
        'ucs2' => 'ucs2'
    );

    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     * @var string[]
     */
    protected static $setters = array(
        'keyid' => 'setKeyid',
        'date_envoi' => 'setDateEnvoi',
        'sms' => 'setSms',
        'num' => 'setNum',
        'emetteur' => 'setEmetteur',
        'tracker' => 'setTracker',
        'smslong' => 'setSmslong',
        'nostop' => 'setNostop',
        'ucs2' => 'setUcs2'
    );

    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     * @var string[]
     */
    protected static $getters = array(
        'keyid' => 'getKeyid',
        'date_envoi' => 'getDateEnvoi',
        'sms' => 'getSms',
        'num' => 'getNum',
        'emetteur' => 'getEmetteur',
        'tracker' => 'getTracker',
        'smslong' => 'getSmslong',
        'nostop' => 'getNostop',
        'ucs2' => 'getUcs2'
    );

    public static function getters()
    {
        return self::$getters;
    }

    

    

    /**
     * Associative array for storing property values
     * @var mixed[]
     */
    protected $container = array();

    /**
     * Constructor
     * @param mixed[] $data Associated array of property value initalizing the model
     */
    public function __construct(array $data = null)
    {
        $this->container['keyid'] = isset($data['keyid']) ? $data['keyid'] : null;
        $this->container['date_envoi'] = isset($data['date_envoi']) ? $data['date_envoi'] : null;
        $this->container['sms'] = isset($data['sms']) ? $data['sms'] : null;
        $this->container['num'] = isset($data['num']) ? $data['num'] : null;
        $this->container['emetteur'] = isset($data['emetteur']) ? $data['emetteur'] : null;
        $this->container['tracker'] = isset($data['tracker']) ? $data['tracker'] : null;
        $this->container['smslong'] = isset($data['smslong']) ? $data['smslong'] : null;
        $this->container['nostop'] = isset($data['nostop']) ? $data['nostop'] : null;
        $this->container['ucs2'] = isset($data['ucs2']) ? $data['ucs2'] : null;
    }

    /**
     * show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalid_properties = array();
        if ($this->container['keyid'] === null) {
            $invalid_properties[] = "'keyid' can't be null";
        }
        if ($this->container['sms'] === null) {
            $invalid_properties[] = "'sms' can't be null";
        }
        if ($this->container['num'] === null) {
            $invalid_properties[] = "'num' can't be null";
        }
        return $invalid_properties;
    }

    /**
     * validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properteis are valid
     */
    public function valid()
    {
        if ($this->container['keyid'] === null) {
            return false;
        }
        if ($this->container['sms'] === null) {
            return false;
        }
        if ($this->container['num'] === null) {
            return false;
        }
        return true;
    }


    /**
     * Gets keyid
     * @return string
     */
    public function getKeyid()
    {
        return $this->container['keyid'];
    }

    /**
     * Sets keyid
     * @param string $keyid Clé API
     * @return $this
     */
    public function setKeyid($keyid)
    {
        $this->container['keyid'] = $keyid;

        return $this;
    }

    /**
     * Gets date_envoi
     * @return string
     */
    public function getDateEnvoi()
    {
        return $this->container['date_envoi'];
    }

    /**
     * Sets date_envoi
     * @param string $date_envoi Paramètre optionnel, date d'envoi au format YYYY-MM-DD hh:mm
     * @return $this
     */
    public function setDateEnvoi($date_envoi)
    {
        $this->container['date_envoi'] = $date_envoi;

        return $this;
    }

    /**
     * Gets sms
     * @return string[]
     */
    public function getSms()
    {
        return $this->container['sms'];
    }

    /**
     * Sets sms
     * @param string[] $sms
     * @return $this
     */
    public function setSms($sms)
    {
        $this->container['sms'] = $sms;

        return $this;
    }

    /**
     * Gets num
     * @return string[]
     */
    public function getNum()
    {
        return $this->container['num'];
    }

    /**
     * Sets num
     * @param string[] $num
     * @return $this
     */
    public function setNum($num)
    {
        $this->container['num'] = $num;

        return $this;
    }

    /**
     * Gets emetteur
     * @return string
     */
    public function getEmetteur()
    {
        return $this->container['emetteur'];
    }

    /**
     * Sets emetteur
     * @param string $emetteur L'emetteur doit être une chaîne alphanumérique comprise entre 4 et 11 caractères. Les caractères acceptés sont les chiffres entre 0 et 9, les lettres entre A et Z et l’espace. Il ne peut pas comporter uniquement des chiffres. Pour la modification de l’émetteur et dans le cadre de campagnes commerciales, les opérateurs imposent contractuellement d’ajouter en fin de message le texte suivant : STOP XXXXX De ce fait, le message envoyé ne pourra excéder une longueur de 148 caractères au lieu des 160 caractères, le « STOP » étant rajouté automatiquement.
     * @return $this
     */
    public function setEmetteur($emetteur)
    {
        $this->container['emetteur'] = $emetteur;

        return $this;
    }

    /**
     * Gets tracker
     * @return string[]
     */
    public function getTracker()
    {
        return $this->container['tracker'];
    }

    /**
     * Sets tracker
     * @param string[] $tracker
     * @return $this
     */
    public function setTracker($tracker)
    {
        $this->container['tracker'] = $tracker;

        return $this;
    }

    /**
     * Gets smslong
     * @return string
     */
    public function getSmslong()
    {
        return $this->container['smslong'];
    }

    /**
     * Sets smslong
     * @param string $smslong Le SMS long permet de dépasser la limite de 160 caractères en envoyant un message constitué de plusieurs SMS. Il est possible d’envoyer jusqu’à 6 SMS concaténés pour une longueur totale maximale de 918 caractères par message. Pour des raisons technique, la limite par SMS concaténé étant de 153 caractères. En cas de modification de l’émetteur, il faut considérer l’ajout automatique de 12 caractères du « STOP SMS ». Pour envoyer un smslong, il faut ajouter le paramètre smslong aux appels. La valeur de SMS doit être le nombre maximum de sms concaténé autorisé.   Pour ne pas avoir ce message d’erreur et obtenir un calcul dynamique du nombre de SMS alors il faut renseigner smslong = \"999\"
     * @return $this
     */
    public function setSmslong($smslong)
    {
        $this->container['smslong'] = $smslong;

        return $this;
    }

    /**
     * Gets nostop
     * @return string
     */
    public function getNostop()
    {
        return $this->container['nostop'];
    }

    /**
     * Sets nostop
     * @param string $nostop Si le message n’est pas à but commercial, vous pouvez faire une demande pour retirer l’obligation du STOP. Une fois votre demande validée par nos services, vous pourrez supprimer la mention STOP SMS en ajoutant nostop = \"1\"
     * @return $this
     */
    public function setNostop($nostop)
    {
        $this->container['nostop'] = $nostop;

        return $this;
    }

    /**
     * Gets ucs2
     * @return string
     */
    public function getUcs2()
    {
        return $this->container['ucs2'];
    }

    /**
     * Sets ucs2
     * @param string $ucs2 Il est également possible d’envoyer des SMS en alphabet non latin (russe, chinois, arabe, etc) sur les numéros hors France métropolitaine. Pour ce faire, la requête devrait être encodée au format UTF-8 et contenir l’argument ucs2 = \"1\" Du fait de contraintes techniques, 1 SMS unique ne pourra pas dépasser 70 caractères (au lieu des 160 usuels) et dans le cas de SMS long, chaque sms ne pourra dépasser 67 caractères.
     * @return $this
     */
    public function setUcs2($ucs2)
    {
        $this->container['ucs2'] = $ucs2;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     * @param  integer $offset Offset
     * @return boolean
     */
    public function offsetExists($offset)
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     * @param  integer $offset Offset
     * @return mixed
     */
    public function offsetGet($offset)
    {
        return isset($this->container[$offset]) ? $this->container[$offset] : null;
    }

    /**
     * Sets value based on offset.
     * @param  integer $offset Offset
     * @param  mixed   $value  Value to be set
     * @return void
     */
    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     * @param  integer $offset Offset
     * @return void
     */
    public function offsetUnset($offset)
    {
        unset($this->container[$offset]);
    }

    /**
     * Gets the string presentation of the object
     * @return string
     */
    public function __toString()
    {
        if (defined('JSON_PRETTY_PRINT')) { // use JSON pretty print
            return json_encode(\Swagger\Client\ObjectSerializer::sanitizeForSerialization($this), JSON_PRETTY_PRINT);
        }

        return json_encode(\Swagger\Client\ObjectSerializer::sanitizeForSerialization($this));
    }
}


